const mongoose = require('mongoose');
const validator = require('validator');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const { isValidPassword } = require('mongoose-custom-validators')
const { Schema } = mongoose;

const UserSchema = new Schema({
    name: {
        type: String,
        required: [true, 'A user has a name'],
        maxlength: [40, 'The maximum length is 40']
    },
    email: {
        type: String,
        required: [true, 'A user has a email'],
        validate: [validator.isEmail, 'please enter correct email address'],
        unique: true,
    },
    password: {
        type: String,
        required: [true, 'A user has a password'],
        // Commented for the purpose of testing
        // validate: {
        //     validator: isValidPassword,
        //     message: 'Password must have at least: 1 uppercase letter, 1 lowercase letter, 1 number, and 1 special character.'
        // },
        // unique: true,
        // select: false
    },
    position: {
        type: String,
        // required: true,
        default: 'user',
    },
    photo: {
        id: {
            type: String,
            // required: true,
        },
        secure_url: {
            type: String,
            // required: true,
        }
    },
    forgotPasswordToken: {
        type: String,
    },
    forgotPasswordExpairy: {
        type: Date,
    },
    createdAt: {
        type: Date,
        default: new Date,
    }
});
//* encrypt password before save⭐⭐
// Pre function is just here doing just before saving the schema into the db 
UserSchema.pre('save', async function (next) {
    // if password is not changed while saving into db then do nothing
    if (!this.isModified('password'))
        return next();

    // in case password is changed while saving into db (like in the case of forgot password we need to change password) we need to modify the password and hash again
    this.password = await bcrypt.hash(this.password, 10);
});

UserSchema.methods.comparePassword = function (myPassword, cb) {
    bcrypt.compare(myPassword, this.password, (err, isMatch) => {
        if (err) return cb(err);
        else {
            cb(null, isMatch);
            return;
        }
    });
}

// create a jwt token based upon the object _id which is automatically generated by mongodb
UserSchema.methods.getJwtToken = function () {
    return jwt.sign({ id: this._id }, process.env.JWT_SECRET, {
        expiresIn: process.env.JWT_EXPIRATION
    })
}

// Genrate forgot password token 
UserSchema.methods.getPasswordToken = function () {
    const token = crypto.randomBytes(30).toString('hex');

    // getting a hash value we need to de hash the token for checking the token validity and correctness. (example:- this is useful when we get a forgot password email we check in the backend and if it is valid we allow user to change the password otherwise we dont this token has a valid time to change) we are saving in backend this forgotPasswordToken and when user ask for forgot password we are checking the token via we are returning from function
    this.forgotPasswordToken = crypto.createHash('sha256').update(token).digest('hex');

    // time of token expiry
    this.forgotPasswordExpairy = Date.now() + 100 * 60 * 1000; // 20 minutes

    return token;
}

module.exports = mongoose.model('User', UserSchema);

/*
validate: ,
*/